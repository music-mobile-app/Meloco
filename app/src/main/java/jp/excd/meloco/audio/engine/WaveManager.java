//--------------------------------------------------------------------------------------------------
// 波形生成管理クラス
// 全ての波形を、このクラスのインスタンスで生成する。
// アクティブな音源の参照、更新は、同時にひとつのスレッドだけが行うことができる。
//--------------------------------------------------------------------------------------------------
package jp.excd.meloco.audio.engine;

import android.media.AudioFormat;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;
import jp.excd.meloco.audio.engine.ActiveNote;
import jp.excd.meloco.utility.CommonUtil;
import jp.excd.meloco.utility.WLog;

public class WaveManager extends Thread{
    //----------------------------------------------------------------------------------------------
    // 排他用オブジェクト
    //----------------------------------------------------------------------------------------------
    // 波形アクセス中
    // 同時にひとつのスレッドのみが、波形データへのアクセスを許される
    // また、アクティブ音源がない場合、このオブジェクトをwait()する。
    // アクティブ音源を設定するスレッドは、アクティブな音源ができたら、notifyAll()する。
    public static Object waveDataAccess = new Object();

    // 次の波形データあり
    // 次の波形データの待ち合わせをするための、ロック用オブジェクト
    // 「AudioTrackWrapper」は、次の波形データがない場合、このオブジェクトをwait（）する。
    // 次の波形データが存在している場合は、notifyAllする。
    // 「WaveManager」は、次の波形データを更新できないとき（AudioTrackWrapperが処理中のとき、このオブジェクトをwait()する。
    // 次の波形データが更新できたとき、notifyAllする。
    public static Object nextDataLock = new Object();

    //----------------------------------------------------------------------------------------------
    // 発音中のデータ群
    // このデータ（内部に抱えているインスタンスを含む）にアクセスする場合には、
    // waveDataAccessをロックする。
    //----------------------------------------------------------------------------------------------
    // 現在鳴っている音源群
    private static Map<String ,ActiveNote> activeNotes;

    //----------------------------------------------------------------------------------------------
    // 次に返却するデータ
    // このデータを更新する場合は「nextDataLock」をロックした状態で行う。
    //----------------------------------------------------------------------------------------------
    //次に返却するデータ(16bitの場合)
    private short[] nextData16bit;

    //次に返却するデータ(8bitの場合)
    private byte[] nextData8bit;

    //次に返却するデータの状態
    private boolean allready = false;

    //----------------------------------------------------------------------------------------------
    // その他の状況
    //----------------------------------------------------------------------------------------------
    //終了フラグ（外部から強制終了させる場合にtreu)
    public boolean stopFlg = false;

    //AudioTrack停止フラグ
    public boolean audioTrackToStop = false;

    //----------------------------------------------------------------------------------------------
    // コンストラクタ
    //  プライベート化して、外部からインスタンス化できないようにする。
    //----------------------------------------------------------------------------------------------
    private WaveManager() {
        WLog.d("WaveManagerコンストラクタ");

        synchronized (waveDataAccess) {

            //発音中のデータの初期化
            activeNotes = new HashMap<String, ActiveNote>();
        }
    }
    //----------------------------------------------------------------------------------------------
    // スレッド開始
    //----------------------------------------------------------------------------------------------
    public void run() {

        WLog.d(this, "スレッド実行");

        //強制終了フラグたつまで、ループし続ける。
        while (stopFlg == false) {
            mainLoop();
        }
        WLog.d(this, "スレッド終了");

        WLog.d(this, "AudioWrapperにも、音源生成が終了したことを伝える。");
        this.audioTrackToStop = true;
    }
    //----------------------------------------------------------------------------------------------
    // メイン処理
    //----------------------------------------------------------------------------------------------
    private void mainLoop() {

        //波形データの入れ物
        short[] shorts = null;

        synchronized (waveDataAccess) {

            //波形データの取得
            shorts = getNextData();

            //波形データが取得できない場合は、待ち合わせ
            try {
                WLog.d(this, "波形データが取得できないのでwait");
                wait();
            }catch (InterruptedException e) {
                WLog.d(this, "音源更新プロセスより通知あり");
            }

        }
        if (( shorts == null)||( shorts.length == 0)) {
            WLog.d(this, "波形データが取得できていないので、更新しない。");
        } else {
            WLog.d(this, "波形データをAudioTrackWrapperに伝える。");
            nextDataUpdate(shorts);
        }
    }
    //----------------------------------------------------------------------------------------------
    // 波形データの更新
    // 第１引数：更新する波形データ
    //           型は、short[]であるが、8bitエンコーディングの設定の場合には、
    //           byteの幅を越えないデータが設定されている。
    //----------------------------------------------------------------------------------------------
    private void nextDataUpdate(short[] shorts) {

        WLog.d(this, "nextDataUpdate()");

        boolean loopOn = true;
        while(loopOn) {
            //------------------------------------------------------------------------------------------
            // 波形データの更新
            //------------------------------------------------------------------------------------------
            synchronized(nextDataLock) {
                //次の波形データを受け入れ可能な状態かどうかを確認
                if (this.allready) {
                    //未処理の場合は、処理済みになるのを待つ。
                    try {
                        WLog.d(this, "未処理のため、処理済みになるのを待つ");
                        wait();
                    } catch (InterruptedException e){
                        WLog.d(this, "AudioTrackWrapperより通知あり");
                    }
                } else {
                    //受け入れ可能な場合は、更新
                    //8bitの場合、byteで返却
                    if (AudioConfig.AUDIO_FORMAT == AudioFormat.ENCODING_PCM_8BIT) {
                        this.nextData8bit = CommonUtil.from16to8(shorts);
                    } else {
                        this.nextData16bit = shorts;
                    }
                    //状態の更新
                    this.allready = true;

                    //状態が更新されたことをAudioTrackWrapperに通知
                    notifyAll();

                    //ループフラグのクリア
                    loopOn = false;
                }
            }
        }
    }
    //----------------------------------------------------------------------------------------------
    // 名称    ：次の波形データの取得
    // 処理概要：アクティブな音源から波形データを編集して返却する。
    // 注意点　：このメソッドは、waveDataAccessに対するロックを取得している状態で、
    //           呼び出されることを前提としている。
    //           ロックを獲得せずに呼び出すと、音源データの不整合で異常終了する。
    // 戻り値　：１ループバッファ分の波形データ
    //         　モノラル形式の場合は、配列数　＝　ループバッファ数
    //         　ステレオ形式の場合は、配列数　＝　ループバッファ数の２倍（左右のデータ交互に入る）
    //         　アクティブなデータが存在しない場合はnullを返却する。
    //----------------------------------------------------------------------------------------------
    private short[] getNextData() {

        WLog.d(this, "getNextData()");

        //------------------------------------------------------------------------------------------
        // アクティブな音源の存在確認
        //------------------------------------------------------------------------------------------
        if ((activeNotes == null)||(activeNotes.length == 0)) {
            WLog.d(this, "アクティブな音源が存在しない");
            return null;
        }
        //------------------------------------------------------------------------------------------
        // 配列数の計算
        //------------------------------------------------------------------------------------------
        int size = AudioConfig.LOOP_BUFFER_SIZE;
        if (AudioConfig.CHANNEL_CONFIG == AudioFormat.CHANNEL_OUT_STEREO) {
            //２倍する。
            size = size * 2;
        }
        //------------------------------------------------------------------------------------------
        // 計算した波形の入れ物
        //------------------------------------------------------------------------------------------
        int[] waves = new int[size];

        //------------------------------------------------------------------------------------------
        // すべてのアクティブな音源から波形データを獲得して足し合わせる。
        //------------------------------------------------------------------------------------------
        for(Map.Entry<String, ActiveNote> entry : activeNotes.entrySet()) {
            //キー
            String key = entry.getKey();
            //実体
            ActiveNote activeNote = entry.getValue();
            //波形の取得
            int[] targetWave = activeNote.getAndUpdateWaveData();

            //波形の加算処理
            waves = CommonUtil.addWave(waves, targetWave);

            //状況の確認
            boolean toEnd = activeNote.isEnd();
            if (toEnd) {
                //アクティブノードから削除
                activeNotes.remove(key);
            }
        }
        //------------------------------------------------------------------------------------------
        // int配列をshort配列の範囲まで圧縮する。
        //------------------------------------------------------------------------------------------
        short[] rets = CommonUtil.compressWaveData(waves);

        return retsu;
    }

}
