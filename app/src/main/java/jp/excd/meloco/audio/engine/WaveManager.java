//--------------------------------------------------------------------------------------------------
// 波形生成管理クラス
// 全ての波形を、このクラスのインスタンスで生成する。
// アクティブな音源の参照、更新は、同時にひとつのスレッドだけが行うことができる。
//--------------------------------------------------------------------------------------------------
package jp.excd.meloco.audio.engine;

import android.media.AudioFormat;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.locks.ReentrantLock;
import jp.excd.meloco.audio.engine.ActiveNote;
import jp.excd.meloco.utility.CommonUtil;
import jp.excd.meloco.utility.WLog;

public class WaveManager extends Thread{
    //----------------------------------------------------------------------------------------------
    // 排他用オブジェクト
    //----------------------------------------------------------------------------------------------
    // 波形アクセス中
    // このセマフォがONの場合は、波形データの参照もしくは、更新をしている
    // 同時にひとつのスレッドのみが、波形データへのアクセスを許される
    public static ReentrantLock waveDataAccess = new ReentrantLock();

    // 次の波形データあり
    // 次の波形データの待ち合わせをするための、ロック用オブジェクト
    // 「AudioTrackWrapper」は、次の波形データがない場合、このオブジェクトをwait（）する。
    // 次の波形データが存在している場合は、notifyAllする。
    // 「WaveManager」は、次の波形データを更新できないとき（AudioTrackWrapperが処理中のとき、このオブジェクトをwait()する。
    // 次の波形データが更新できたとき、notifyAllする。
    public static Object nextDataLock = new Object();

    // アクティブ音源あり
    // アクティブ音源の有無を確認するための、ロック用オブジェクト
    // アクティブ音源がなくなったら、このオブジェクトを取得して、wait()、音源を追加する側はnotfyAll()する。
    public static Object activeNoteLock = new Object();

    //----------------------------------------------------------------------------------------------
    // 発音中のデータ群
    // このデータ（内部に抱えているインスタンスを含む）にアクセスする場合には、
    // waveDataAccessをロックする。
    //----------------------------------------------------------------------------------------------
    // 現在鳴っている音源群
    private Map<String ,ActiveNote> activeNotes;

    //----------------------------------------------------------------------------------------------
    // 次に返却するデータ
    // このデータを更新する場合は「nextDataLock」をロックした状態で行う。
    //----------------------------------------------------------------------------------------------
    //次に返却するデータ(16bitの場合)
    private short[] nextData16bit;

    //次に返却するデータ(8bitの場合)
    private byte[] nextData8bit;

    //次に返却するデータの状態
    private boolean allready = false;

    //----------------------------------------------------------------------------------------------
    // その他の状況
    //----------------------------------------------------------------------------------------------
    //終了フラグ（外部から強制終了させる場合にtreu)
    public boolean stopFlg = false;

    //----------------------------------------------------------------------------------------------
    // コンストラクタ
    //----------------------------------------------------------------------------------------------
    //----------------------------------------------------------------------------------------------
    // コンストラクタ
    //  プライベート化して、外部からインスタンス化できないようにする。
    //----------------------------------------------------------------------------------------------
    private WaveManager() {
        WLog.d("WaveManagerコンストラクタ");

        try {
            //ロック取得
            waveDataAccess.lock();

            //発音中のデータの初期化
            this.activeNotes = new HashMap<String, ActiveNote>();
        } finally {
            //ロック解放
            waveDataAccess.unlock();
        }
    }
    //----------------------------------------------------------------------------------------------
    // スレッド開始
    //----------------------------------------------------------------------------------------------
    public void run() {

        WLog.d(this, "スレッド実行");

        //強制終了フラグたつまで、ループし続ける。
        while (stopFlg == false) {
            mainLoop();
        }
        WLog.d(this, "スレッド終了");
    }
    //----------------------------------------------------------------------------------------------
    // メイン処理
    //----------------------------------------------------------------------------------------------
    private void mainLoop() {

        //波形データの入れ物
        short[] shorts = null;
        //------------------------------------------------------------------------------------------
        //次の波形の生成処理
        //------------------------------------------------------------------------------------------
        try {
            //発音中データロック取得
            waveDataAccess.lock();

            //波形データの取得
            shorts = getNextData();

        } finally {
            //ロック解放
            waveDataAccess.unlock();
        }
        //------------------------------------------------------------------------------------------
        // 波形データの更新
        //------------------------------------------------------------------------------------------
        nextDataUpdate(shorts);
    }
    //----------------------------------------------------------------------------------------------
    // 波形データの更新
    //----------------------------------------------------------------------------------------------
    private void nextDataUpdate(short[] shorts) {

        boolean loopOn = true;
        while(loopOn) {
            //------------------------------------------------------------------------------------------
            // 波形データの更新
            //------------------------------------------------------------------------------------------
            synchronized(nextDataLock) {
                //次の波形データを受け入れ可能な状態かどうかを確認
                if (this.allready) {
                    //未処理の場合は、処理済みになるのを待つ。
                    try {
                        wait();
                    } catch (InterruptedException e){
                        WLog.d(this, "AudioTrackWrapperより通知あり");
                    }
                }
                //受け入れ可能な場合は、更新
                //8bitの場合、byteで返却
                if (AudioConfig.AUDIO_FORMAT == AudioFormat.ENCODING_PCM_8BIT) {
                    this.nextData8bit = CommonUtil.from16to8(shorts);
                } else {
                    this.nextData16bit = shorts;
                }
                //状態の更新
                this.allready = true;

                //状態が更新されたことをAudioTrackWrapperに通知
                notifyAll();

                //ループフラグのクリア
                loopOn = false;
            }
        }
    }
    //----------------------------------------------------------------------------------------------
    // 次の波形データの取得
    //----------------------------------------------------------------------------------------------
    private short[] getNextData() {
        //TODO 実装する。
        return null;
    }
}
